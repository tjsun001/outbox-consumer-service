############################################################
# Kafka / MSK bootstrap configuration
############################################################

# Prefer ECS variable SPRING_KAFKA_BOOTSTRAP_SERVERS
# Fall back to KAFKA_BOOTSTRAP_SERVERS
# Fall back to localhost for local dev
spring.kafka.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS:${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}}

############################################################
# Consumer group configuration
############################################################

spring.kafka.consumer.group-id=${KAFKA_CONSUMER_GROUP_ID:product-consumer-v1}

# Read existing messages when group is new (important for smoketest)
spring.kafka.consumer.auto-offset-reset=${KAFKA_AUTO_OFFSET_RESET:earliest}

# Manual offset control (matches your architecture for long-running consumers)
spring.kafka.consumer.enable-auto-commit=false
spring.kafka.listener.ack-mode=manual

############################################################
# Stability / timeout tuning (safe defaults)
############################################################

spring.kafka.consumer.properties.max.poll.interval.ms=${KAFKA_MAX_POLL_INTERVAL_MS:300000}
spring.kafka.consumer.properties.session.timeout.ms=${KAFKA_SESSION_TIMEOUT_MS:45000}

############################################################
# Deserializers (string messages)
############################################################

spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

############################################################
# Topic configuration (raw env-facing)
############################################################

KAFKA_TOPIC_OUTBOX=${KAFKA_TOPIC_OUTBOX:outbox.events.test}

############################################################
# App aliases (cleaner placeholders in code)
############################################################

app.topic=${KAFKA_TOPIC_OUTBOX}
app.poll-seconds=${APP_POLL_SECONDS:30}

app.consumer.max-messages=${APP_MAX_MESSAGES:1}
app.consumer.exit-after-consume=${APP_EXIT_AFTER_CONSUME:true}

############################################################
# One-off consumer runner (consume once + exit)
############################################################

app.consumer.once.enabled=${APP_CONSUMER_ONCE_ENABLED:true}

# Derive from app aliases so there is ONE source of truth
app.consumer.once.poll-seconds=${app.poll-seconds}
app.consumer.once.max-messages=${app.consumer.max-messages}

# Group behavior
app.consumer.once.group-id=${KAFKA_CONSUMER_GROUP_ID:outbox-consumer-smoketest-v1}
app.consumer.once.randomize-group=${APP_RANDOMIZE_GROUP:true}

# Treat "received at least 1" as success even if max-messages not hit
app.consumer.once.success-if-any=${APP_SUCCESS_IF_ANY:true}

# Exit behavior (ECS likes real process exit codes)
app.consumer.once.force-exit=${APP_FORCE_EXIT:true}

# Optional tuning
app.consumer.once.poll-ms=${APP_POLL_MS:1000}
app.consumer.once.max-poll-records=${APP_MAX_POLL_RECORDS:50}